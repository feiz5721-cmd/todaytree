<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas Tree | Creative Tech Demo</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #000000;
            --gold: #d4af37;
            --cream: #fceea7;
        }
/* 全屏按钮样式 */
.fullscreen-toggle {
    display: inline-block;
    padding: 12px 30px;
    cursor: pointer;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    border: 1px solid var(--gold);
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 14px;
    letter-spacing: 2px;
    transition: all 0.3s ease;
    border-radius: 2px;
    margin-top: 10px; /* 与上传按钮拉开距离 */
    pointer-events: auto;
}

.fullscreen-toggle:hover {
    background: rgba(212, 175, 55, 0.2);
    box-shadow: 0 0 15px var(--gold);
}
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Times New Roman', serif;
            user-select: none;
        }

        /* UI Container */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        .ui-hidden {
            opacity: 0;
            pointer-events: none !important;
        }

        /* Title */
        h1 {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: 56px;
            margin: 0;
            background: linear-gradient(to bottom, #ffffff, var(--gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.5));
            letter-spacing: 2px;
            pointer-events: auto;
        }

        /* Upload Controls */
        .upload-wrapper {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .custom-file-upload {
            display: inline-block;
            padding: 12px 30px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Cinzel', serif;
            font-size: 14px;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            border-radius: 2px;
        }

        .custom-file-upload:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 15px var(--gold);
        }

        input[type="file"] {
            display: none;
        }

        .hint-text {
            color: rgba(252, 238, 167, 0.6);
            font-size: 12px;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        /* Loader */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(212, 175, 55, 0.1);
            border-top: 2px solid var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            color: var(--gold);
            font-family: 'Cinzel', serif;
            font-size: 14px;
            letter-spacing: 4px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Hidden CV Elements */
        .cv-hidden {
            position: fixed;
            bottom: 0;
            right: 0;
            opacity: 0; 
            pointer-events: none;
            z-index: -1;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">LOADING HOLIDAY MAGIC</div>
    </div>

    <div id="ui-container">
        <h1>Merry Christmas</h1>
        
       <div class="upload-wrapper">
    <label class="custom-file-upload">
        <input type="file" id="imageUpload" accept="image/*">
        ADD MEMORIES
    </label>
    
    <button id="fullscreenBtn" class="fullscreen-toggle">ENTER FULLSCREEN</button>
    
    <div class="hint-text">Press 'H' to Hide UI | Press 'F' for Fullscreen</div>
</div>
    </div>

    <div class="cv-hidden">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas" width="160" height="120"></canvas>
    </div>

   <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- 1. Configuration ---
    const PARTICLE_COUNT = 1500;
    const DUST_COUNT = 2500;
    const STATE = {
        mode: 'TREE',
        targetRotation: { x: 0, y: 0 },
        focusedPhotoIndex: -1,
        hoveredPhotoIndex: -1
    };

    // --- 2. Global Variables ---
    let camera, scene, renderer, composer, mainGroup;
    let particles = [], dustParticles, handLandmarker, webcam, lastVideoTime = -1;
    let uiVisible = true;
    let matGold, matGreen, matRed, matFrame;

    // --- 3. Persistence (IndexedDB) ---
    const DB_NAME = 'ChristmasTreeDB', STORE_NAME = 'photos';
    const StorageManager = {
        db: null,
        async init() {
            return new Promise((resolve) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => e.target.result.createObjectStore(STORE_NAME, { autoIncrement: true });
                request.onsuccess = (e) => { this.db = e.target.result; resolve(); };
            });
        },
        async savePhoto(file) {
            const tx = this.db.transaction([STORE_NAME], 'readwrite');
            tx.objectStore(STORE_NAME).add(file);
        },
        async loadAllPhotos(callback) {
            const store = this.db.transaction([STORE_NAME], 'readonly').objectStore(STORE_NAME);
            const req = store.openCursor();
            req.onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor) { callback(URL.createObjectURL(cursor.value)); cursor.continue(); }
            };
        },
        async clear() {
            this.db.transaction([STORE_NAME], 'readwrite').objectStore(STORE_NAME).clear();
            alert("Memories cleared. Refreshing...");
            location.reload();
        }
    };

    // --- 4. Initialization ---
    init();

    async function init() {
        await StorageManager.init();
        setupScene();
        setupMaterials();
        createContent();
        
        // 加载预设与本地照片
        loadPhotos();
        
        setupEvents();
        await setupMediaPipe();

        // 成功运行到这里，遮罩层才会消失
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').remove(), 1000);
        animate();
    }

    function setupScene() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 50);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.2;
        document.body.appendChild(renderer.domElement);

        const pmrem = new THREE.PMREMGenerator(renderer);
        scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const spot = new THREE.SpotLight(0xd4af37, 1200);
        spot.position.set(30, 40, 40);
        scene.add(spot);

        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.45, 0.4, 0.7));
        
        mainGroup = new THREE.Group();
        scene.add(mainGroup);
    }

    function setupMaterials() {
        matGold = new THREE.MeshStandardMaterial({ color: 0xd4af37, roughness: 0.3, metalness: 1.0 });
        matGreen = new THREE.MeshStandardMaterial({ color: 0x0f3b1e, roughness: 0.6, metalness: 0.2 });
        matRed = new THREE.MeshPhysicalMaterial({ color: 0xcc0000, clearcoat: 1.0 });
        matFrame = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 1.0 });
    }

    function createContent() {
        // 创建粒子和雪花
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const geo = Math.random() > 0.6 ? new THREE.BoxGeometry(0.4, 0.4, 0.4) : new THREE.SphereGeometry(0.25, 16, 16);
            const mesh = new THREE.Mesh(geo, Math.random() > 0.3 ? matGreen : matGold);
            mesh.userData = { 
                treePos: calculateTreePos(i, PARTICLE_COUNT),
                scatterPos: new THREE.Vector3().randomDirection().multiplyScalar(15),
                randomRotation: { x: Math.random()*0.02, y: Math.random()*0.02 }
            };
            mainGroup.add(mesh);
            particles.push(mesh);
        }
        createDust();
    }

    function loadPhotos() {
        const PHOTO_COUNT = 30, PHOTO_DIR = 'memories/', loader = new THREE.TextureLoader();
        // 加载预设
        for (let i = 1; i <= PHOTO_COUNT; i++) {
            loader.load(`./${PHOTO_DIR}${i}.jpg`, (t) => {
                t.colorSpace = THREE.SRGBColorSpace;
                addPhotoToScene(t, i, PHOTO_COUNT);
            });
        }
        // 加载本地存储
        StorageManager.loadAllPhotos((url) => {
            loader.load(url, (t) => { t.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(t, 1, 30); });
        });
    }

    function addPhotoToScene(texture, index, total) {
        const aspect = texture.image ? texture.image.width / texture.image.height : 1.5;
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(2.5 * aspect, 2.5, 0.1), [matFrame, matFrame, matFrame, matFrame, new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }), matFrame]);
        const t = Math.random();
        mesh.userData = { 
            type: 'PHOTO', 
            treePos: calculateTreePosFromT(t), 
            scatterPos: new THREE.Vector3().randomDirection().multiplyScalar(12),
            randomRotation: { x: 0.01, y: 0.01 },
            originalScale: new THREE.Vector3(1, 1, 1)
        };
        mainGroup.add(mesh);
        particles.push(mesh);
    }

    function calculateTreePos(index, total) { return calculateTreePosFromT(index/total); }
    function calculateTreePosFromT(t) {
        const angle = t * 50 * Math.PI, radius = 12 * (1 - t) + 0.5;
        return new THREE.Vector3(Math.cos(angle) * radius, -10 + t * 20, Math.sin(angle) * radius);
    }

    function createDust() {
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<DUST_COUNT; i++) pos.push((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        dustParticles = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xfceea7, size: 0.1, transparent: true, opacity: 0.6 }));
        scene.add(dustParticles);
    }

    // --- 5. Events & Fullscreen ---
    function setupEvents() {
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        const fsBtn = document.getElementById('fullscreenBtn');
        const toggleFS = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => console.error(e));
                fsBtn.textContent = "EXIT FULLSCREEN";
            } else {
                document.exitFullscreen();
                fsBtn.textContent = "ENTER FULLSCREEN";
            }
        };

        fsBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleFS(); });
        
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'f') toggleFS();
            if (k === 'h') { uiVisible = !uiVisible; document.getElementById('ui-container').style.opacity = uiVisible ? 1 : 0; }
            if (k === 'c') StorageManager.clear();
        });

        document.getElementById('imageUpload').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if (!f) return;
            StorageManager.savePhoto(f);
            const reader = new FileReader();
            reader.onload = (ev) => {
                new THREE.TextureLoader().load(ev.target.result, (t) => {
                    t.colorSpace = THREE.SRGBColorSpace;
                    addPhotoToScene(t, 1, 30);
                });
            };
            reader.readAsDataURL(f);
        });
        
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) fsBtn.textContent = "ENTER FULLSCREEN";
        });
    }

    // --- 6. CV & Animation ---
    async function setupMediaPipe() {
        try {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1, minHandDetectionConfidence: 0.7
            });
            webcam = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            webcam.srcObject = stream;
            await new Promise((r) => webcam.onloadeddata = r);
        } catch (e) { console.warn("CV Failed", e); }
    }

    function animate() {
        requestAnimationFrame(animate);
        if (handLandmarker && webcam && webcam.currentTime !== lastVideoTime) {
            lastVideoTime = webcam.currentTime;
            const results = handLandmarker.detectForVideo(webcam, performance.now());
            processGestures(results);
        }

        mainGroup.rotation.y += (STATE.targetRotation.y - mainGroup.rotation.y) * 0.05;
        mainGroup.rotation.x += (STATE.targetRotation.x - mainGroup.rotation.x) * 0.05;
        if (STATE.mode === 'TREE') mainGroup.rotation.y += 0.002;

        particles.forEach((p, i) => {
            const data = p.userData;
            let targetPos = new THREE.Vector3(), targetScale = new THREE.Vector3(1, 1, 1);
            
            if (STATE.mode === 'TREE') targetPos.copy(data.treePos);
            else if (STATE.mode === 'SCATTER') {
                targetPos.copy(data.scatterPos);
                p.rotation.x += data.randomRotation.x; p.rotation.y += data.randomRotation.y;
            } else if (STATE.mode === 'FOCUS' && i === STATE.focusedPhotoIndex) {
                targetPos.set(0, 2, 35); targetScale.set(4.5, 4.5, 4.5);
                p.lookAt(camera.position); p.position.lerp(targetPos, 0.05); p.scale.lerp(targetScale, 0.05); return;
            }

            if (STATE.hoveredPhotoIndex === i && STATE.mode !== 'FOCUS') {
                targetScale.multiplyScalar(3.5); targetPos.add(p.position.clone().normalize().multiplyScalar(4));
                p.lookAt(camera.position); p.position.lerp(targetPos, 0.2); p.scale.lerp(targetScale, 0.3);
            } else {
                p.position.lerp(targetPos, 0.03); p.scale.lerp(targetScale, 0.1);
            }
        });
        if (dustParticles) dustParticles.rotation.y -= 0.001;
        composer.render();
    }

    function processGestures(res) {
        STATE.hoveredPhotoIndex = -1;
        if (!res.landmarks || res.landmarks.length === 0) return;
        const l = res.landmarks[0], wrist = l[0], dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const isPoint = dist(l[8], wrist) > dist(l[6], wrist) * 1.2 && dist(l[12], wrist) < dist(l[10], wrist);
        
        if (isPoint && STATE.mode !== 'FOCUS') {
            const x = (1 - l[8].x) * 2 - 1, y = -(l[8].y * 2 - 1);
            let minD = Infinity;
            particles.forEach((p, i) => {
                if (p.userData.type === 'PHOTO') {
                    const sPos = p.position.clone().applyMatrix4(mainGroup.matrixWorld).project(camera);
                    const d = Math.hypot(sPos.x - x, sPos.y - y);
                    if (d < 0.4 && d < minD) { minD = d; STATE.hoveredPhotoIndex = i; }
                }
            });
        } else {
            STATE.targetRotation.x = (l[9].y - 0.5); STATE.targetRotation.y = (l[9].x - 0.5) * 2;
            const pinch = dist(l[4], l[8]);
            if (pinch < 0.05) {
                STATE.mode = 'FOCUS';
                const pIdx = particles.map((p, i) => p.userData.type === 'PHOTO' ? i : -1).filter(i => i !== -1);
                STATE.focusedPhotoIndex = pIdx[Math.floor(Math.random()*pIdx.length)];
            } else if (dist(l[12], wrist) > 0.4) STATE.mode = 'SCATTER';
            else STATE.mode = 'TREE';
        }
    }
</script>
</body>

</html>





